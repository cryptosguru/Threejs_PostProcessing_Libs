/**
 * postprocessing v0.0.0 build Dec 08 2015
 * https://github.com/vanruesc/postprocessing
 * Copyright 2015 Raoul van RÃ¼schen, Zlib
 */
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],b):b(a.POSTPROCESSING={},a.THREE)}(this,function(a,b){"use strict";function c(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},fragmentShader:A.fragment,vertexShader:A.vertex})}function d(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null}},fragmentShader:B.fragment,vertexShader:B.vertex})}function e(){b.ShaderMaterial.call(this,{defines:{MIP_LEVEL_1X1:0},uniforms:{lastLum:{type:"t",value:null},currentLum:{type:"t",value:null},delta:{type:"f",value:.016},tau:{type:"f",value:1}},fragmentShader:C.fragment,vertexShader:C.vertex})}function f(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},luminanceMap:{type:"t",value:null},averageLuminance:{type:"f",value:1},maxLuminance:{type:"f",value:16},middleGrey:{type:"f",value:.6}},fragmentShader:D.fragment,vertexShader:D.vertex})}function g(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},tSize:{type:"v2",value:new b.Vector2(256,256)},center:{type:"v2",value:new b.Vector2(.5,.5)},angle:{type:"f",value:1.57},scale:{type:"f",value:1}},fragmentShader:E.fragment,vertexShader:E.vertex})}function h(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},tDisp:{type:"t",value:null},byp:{type:"i",value:0},amount:{type:"f",value:.8},angle:{type:"f",value:.02},seed:{type:"f",value:.02},seedX:{type:"f",value:.02},seedY:{type:"f",value:.02},distortionX:{type:"f",value:.5},distortionY:{type:"f",value:.6},colS:{type:"f",value:.05}},fragmentShader:F.fragment,vertexShader:F.vertex})}function i(a,b){return Math.exp(-(a*a)/(2*b*b))}function j(){b.ShaderMaterial.call(this,{defines:{KERNEL_SIZE_FLOAT:25,KERNEL_SIZE_INT:25},uniforms:{tDiffuse:{type:"t",value:null},uImageIncrement:{type:"v2",value:new b.Vector2(.001953125,0)},cKernel:{type:"fv1",value:[]}},fragmentShader:G.fragment,vertexShader:G.vertex})}function k(){b.ShaderMaterial.call(this,{defines:{RINGS:3,SAMPLES:4},uniforms:{textureWidth:{type:"f",value:1},textureHeight:{type:"f",value:1},focalDepth:{type:"f",value:1},focalLength:{type:"f",value:24},fstop:{type:"f",value:.9},tColor:{type:"t",value:null},tDepth:{type:"t",value:null},maxblur:{type:"f",value:1},showFocus:{type:"i",value:0},manualdof:{type:"i",value:0},vignetting:{type:"i",value:0},depthblur:{type:"i",value:0},threshold:{type:"f",value:.5},gain:{type:"f",value:2},bias:{type:"f",value:.5},fringe:{type:"f",value:.7},znear:{type:"f",value:.1},zfar:{type:"f",value:2e3},noise:{type:"i",value:1},dithering:{type:"f",value:1e-4},pentagon:{type:"i",value:0},shaderFocus:{type:"i",value:1},focusCoords:{type:"v2",value:new b.Vector2}},fragmentShader:H.fragment,vertexShader:H.vertex})}function l(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},time:{type:"f",value:0},nIntensity:{type:"f",value:.5},sIntensity:{type:"f",value:.05},sCount:{type:"f",value:4096},grayscale:{type:"i",value:1}},fragmentShader:I.fragment,vertexShader:I.vertex})}function m(a,b){this.scene=a,this.camera=b,this.enabled=!0,this.clear=!0,this.needsSwap=!1}function n(a){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.material=new c,this.renderTarget=a,void 0===this.renderTarget&&(this.renderTarget=new b.WebGLRenderTarget(window.innerWidth,window.innerHeight,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,stencilBuffer:!1})),this.clear=!1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function o(a,b){m.call(this,a,b),this.inverse=!1}function p(){m.call(this)}function q(a,c){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.textureID=void 0!==c?c:"tDiffuse",this.shader=a,this.renderToScreen=!1,this.needsSwap=!0,this.clear=!1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function r(a,c,d,e,f){m.call(this,a,c),this.overrideMaterial=d,this.clearColor=e,this.clearAlpha=void 0!==f?f:1,this.oldClearColor=new b.Color,this.oldClearAlpha=1}function s(a,d){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.material=new c,this.material.uniforms.tDiffuse.value=a,this.material.uniforms.opacity.value=void 0!==d?d:1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function t(a,g){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.resolution=void 0!==g?g:256,this.adaptive=void 0!==a?!1:!0,this.needsInit=!0,this.luminanceRT=null,this.previousLuminanceRT=null,this.currentLuminanceRT=null,this.materialCopy=new c,this.materialCopy.blending=b.NoBlending,this.materialCopy.depthTest=!1,this.materialLuminance=new d,this.materialLuminance.blending=b.NoBlending,this.materialAdaptiveLuminosity=new e,this.materialAdaptiveLuminosity.defines.MIP_LEVEL_1X1=(Math.log(this.resolution)/Math.log(2)).toFixed(1),this.materialAdaptiveLuminosity.blending=b.NoBlending,this.materialToneMapping=new f,this.materialToneMapping.blending=b.NoBlending,this.needsSwap=!0,this.clear=!1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function u(a){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.material=new g,void 0!==a&&(void 0!==a.tSize&&this.material.uniforms.tSize.value.copy(a.tSize),void 0!==a.center&&this.material.uniforms.center.value.copy(a.center),void 0!==a.angle&&(this.material.uniforms.angle.value=a.angle),void 0!==a.scale&&(this.material.uniforms.scale.value=a.scale)),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function v(a){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),void 0===a&&(a=64),this.material=new h,this.material.uniforms.tDisp.value=this.generateHeightmap(a),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad),this.goWild=!1,this.curF=0,this.generateTrigger()}function w(a,d,e,f){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),a=void 0!==a?a:1,d=void 0!==d?d:25,e=void 0!==e?e:4,f=void 0!==f?f:256,this.renderTargetX=new b.WebGLRenderTarget(f,f,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetY=this.renderTargetX.clone(),this.copyMaterial=new c,this.copyMaterial.uniforms.opacity.value=a,this.copyMaterial.transparent=!0,this.convolutionMaterial=new j,this.convolutionMaterial.uniforms.uImageIncrement.value=J,this.convolutionMaterial.buildKernel(e),this.convolutionMaterial.defines.KERNEL_SIZE_FLOAT=d.toFixed(1),this.convolutionMaterial.defines.KERNEL_SIZE_INT=d.toFixed(0),this.clear=!1,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function x(a,c,d){m.call(this,a,c);var e=void 0!==d.focus?d.focus:1,f=void 0!==d.aspect?d.aspect:c.aspect,g=void 0!==d.aperture?d.aperture:.025,h=void 0!==d.maxBlur?d.maxBlur:1,i=void 0!==d.resolution?i:256;this.renderTargetColor=new b.WebGLRenderTarget(i,i,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetDepth=this.renderTargetColor.clone(),this.depthMaterial=new b.MeshDepthMaterial,this.bokehMaterial=new k,this.bokehMaterial.uniforms.tDepth.value=this.renderTargetDepth,this.bokehMaterial.uniforms.focus.value=e,this.bokehMaterial.uniforms.aspect.value=f,this.bokehMaterial.uniforms.aperture.value=g,this.bokehMaterial.uniforms.maxBlur.value=h,this.renderToScreen=!1,this.clear=!1,this.scene2=new b.Scene,this.camera2=new b.OrthographicCamera(-1,1,1,-1,0,1),this.quad2=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene2.add(this.quad2)}function y(a){m.call(this,new b.Scene,new b.OrthographicCamera(-1,1,1,-1,0,1)),this.material=new l,void 0!==a&&(void 0!==a.grayscale&&(this.material.uniforms.grayscale.value=a.grayscale),void 0!==a.noiseIntensity&&(this.material.uniforms.nIntensity.value=a.noiseIntensity),void 0!==a.scanlinesIntensity&&(this.material.uniforms.sIntensity.value=a.scanlinesIntensity),void 0!==a.scanlinesCount&&(this.material.uniforms.sCount.value=a.scanlinesCount)),this.renderToScreen=!1,this.needsSwap=!0,this.quad=new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)}function z(a,d){if(this.renderer=a,void 0===d){var e=a.getPixelRatio(),f=Math.floor(a.context.canvas.width/e)||1,g=Math.floor(a.context.canvas.height/e)||1,h={minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,stencilBuffer:!1};d=new b.WebGLRenderTarget(f,g,h)}this.renderTarget1=d,this.renderTarget2=d.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],this.copyPass=new q(new c)}b="default"in b?b["default"]:b;var A={fragment:"uniform sampler2D tDiffuse;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	gl_FragColor = opacity * texel;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};c.prototype=Object.create(b.ShaderMaterial.prototype),c.prototype.constructor=c;var B={fragment:"uniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	vec3 luma = vec3(0.299, 0.587, 0.114);\n	float v = dot(texel.rgb, luma);\n\n	gl_FragColor = vec4(v, v, v, texel.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};d.prototype=Object.create(b.ShaderMaterial.prototype),d.prototype.constructor=d;var C={fragment:"uniform sampler2D lastLum;\nuniform sampler2D currentLum;\nuniform float delta;\nuniform float tau;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 lastLum = texture2D(lastLum, vUv, MIP_LEVEL_1X1);\n	vec4 currentLum = texture2D(currentLum, vUv, MIP_LEVEL_1X1);\n\n	float fLastLum = lastLum.r;\n	float fCurrentLum = currentLum.r;\n\n	// Better results with squared input luminance.\n	fCurrentLum *= fCurrentLum;\n\n	// Adapt the luminance using Pattanaik's technique.\n	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n	// fAdaptedLum = sqrt(fAdaptedLum);\n\n	gl_FragColor = vec4(fAdaptedLum, fAdaptedLum, fAdaptedLum, 1.0);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};e.prototype=Object.create(b.ShaderMaterial.prototype),e.prototype.constructor=e;var D={fragment:"uniform sampler2D tDiffuse;\nuniform float middleGrey;\nuniform float maxLuminance;\n\n#ifdef ADAPTED_LUMINANCE\n\n	uniform sampler2D luminanceMap;\n\n#else\n\n	uniform float averageLuminance;\n\n#endif\n\nvarying vec2 vUv;\n\nconst vec3 LUM_CONVERT = vec3(0.299, 0.587, 0.114);\n\nvec3 toneMap(vec3 vColor) {\n\n	#ifdef ADAPTED_LUMINANCE\n\n		// Get the calculated average luminance.\n		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\n\n	#else\n\n		float fLumAvg = averageLuminance;\n\n	#endif\n\n	// Calculate the luminance of the current pixel.\n	float fLumPixel = dot(vColor, LUM_CONVERT);\n\n	// Apply the modified operator (Eq. 4).\n	float fLumScaled = (fLumPixel * middleGrey) / fLumAvg;\n\n	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\n	return fLumCompressed * vColor;\n\n}\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	gl_FragColor = vec4(toneMap(texel.rgb), texel.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};f.prototype=Object.create(b.ShaderMaterial.prototype),f.prototype.constructor=f;var E={fragment:"uniform sampler2D tDiffuse;\nuniform vec2 center;\nuniform vec2 tSize;\nuniform float angle;\nuniform float scale;\n\nvarying vec2 vUv;\n\nfloat pattern() {\n\n	float s = sin(angle);\n	float c = cos(angle);\n\n	vec2 tex = vUv * tSize - center;\n	vec2 point = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * scale;\n\n	return (sin(point.x) * sin(point.y)) * 4.0;\n\n}\n\nvoid main() {\n\n	vec4 color = texture2D(tDiffuse, vUv);\n	float average = (color.r + color.g + color.b) / 3.0;\n\n	gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};g.prototype=Object.create(b.ShaderMaterial.prototype),g.prototype.constructor=g;var F={fragment:"uniform sampler2D tDiffuse;\nuniform sampler2D tDisp;\nuniform int byp;\nuniform float amount;\nuniform float angle;\nuniform float seed;\nuniform float seedX;\nuniform float seedY;\nuniform float distortionX;\nuniform float distortionY;\nuniform float colS;\n\nvarying vec2 vUv;\n\nfloat rand(vec2 co) {\n\n	return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\n}\n\nvoid main() {\n\n	vec2 coord = vUv;\n\n	float xs, ys;\n	vec4 normal;\n\n	vec2 offset;\n	vec4 cr, cga, cb;\n	vec4 snow, color;\n\n	if(byp < 1) {\n\n		xs = floor(gl_FragCoord.x / 0.5);\n		ys = floor(gl_FragCoord.y / 0.5);\n\n		normal = texture2D(tDisp, coord * seed * seed);\n\n		if(coord.y < distortionX + colS && coord.y > distortionX - colS * seed) {\n\n			if(seedX > 0.0){\n\n				coord.y = 1.0 - (coord.y + distortionY);\n\n			} else {\n\n				coord.y = distortionY;\n\n			}\n\n		}\n\n		if(coord.x < distortionY + colS && coord.x > distortionY - colS * seed) {\n\n			if(seedY > 0.0){\n\n				coord.x = distortionX;\n\n			} else {\n\n				coord.x = 1. - (coord.x + distortionX);\n\n			}\n\n		}\n\n		coord.x += normal.x * seedX * (seed / 5.0);\n		coord.y += normal.y * seedY * (seed / 5.0);\n\n		// Adopted from RGB shift shader.\n		offset = amount * vec2(cos(angle), sin(angle));\n		cr = texture2D(tDiffuse, coord + offset);\n		cga = texture2D(tDiffuse, coord);\n		cb = texture2D(tDiffuse, coord - offset);\n		color = vec4(cr.r, cga.g, cb.b, cga.a);\n		snow = 200.0 * amount * vec4(rand(vec2(xs * seed,ys * seed * 50.0)) * 0.2);\n		color += snow;\n\n	} else {\n\n		color = texture2D(tDiffuse, vUv);\n\n	}\n\n	gl_FragColor = color;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};h.prototype=Object.create(b.ShaderMaterial.prototype),h.prototype.constructor=h;var G={fragment:"uniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nuniform float cKernel[KERNEL_SIZE_INT];\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec2 coord = vUv;\n	vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n	for(int i = 0; i < KERNEL_SIZE_INT; ++i) {\n\n		sum += texture2D(tDiffuse, coord) * cKernel[i];\n		coord += uImageIncrement;\n\n	}\n\n	gl_FragColor = sum;\n\n}\n",vertex:"uniform vec2 uImageIncrement;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv - ((KERNEL_SIZE_FLOAT - 1.0) / 2.0) * uImageIncrement;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};j.prototype=Object.create(b.ShaderMaterial.prototype),j.prototype.constructor=j,j.prototype.buildKernel=function(a){var b,c,d,e,f=25,g=2*Math.ceil(3*a)+1;for(g>f&&(g=f),e=.5*(g-1),c=this.uniforms.cKernel.value,c.length=0,d=0,b=0;g>b;++b)c[b]=i(b-e,a),d+=c[b];for(b=0;g>b;++b)c[b]/=d};var H={fragment:"uniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\n\nuniform float focalDepth;\nuniform float focalLength;\nuniform float fstop;\nuniform bool showFocus;\n\nuniform float znear;\nuniform float zfar;\n\nuniform bool manualdof;\nuniform bool vignetting;\nuniform bool shaderFocus;\nuniform bool noise;\nuniform bool depthblur;\nuniform bool pentagon;\n\nuniform vec2 focusCoords;\nuniform float maxblur;\nuniform float threshold;\nuniform float gain;\nuniform float bias;\nuniform float fringe;\nuniform float dithering;\n\nvarying vec2 vUv;\n\nconst float PI = 3.14159265;\nconst float TWO_PI = PI * 2.0;\nconst int samples = SAMPLES; // Samples on the first ring.\nconst int rings = RINGS;\nconst int maxringsamples = rings * samples;\n\nfloat ndofstart = 1.0; \nfloat ndofdist = 2.0;\nfloat fdofstart = 1.0;\nfloat fdofdist = 3.0;\n\nfloat CoC = 0.03; // Circle of Confusion size in mm (35mm film = 0.03mm).\n\nfloat vignout = 1.3;\nfloat vignin = 0.0;\nfloat vignfade = 22.0; \n\nfloat dbsize = 1.25;\nfloat feather = 0.4;\n\n/**\n * Pentagonal shape creation.\n */\n\nfloat penta(vec2 coords) {\n\n	float scale = float(rings) - 1.3;\n\n	vec4  HS0 = vec4( 1.0,          0.0,         0.0,  1.0);\n	vec4  HS1 = vec4( 0.309016994,  0.951056516, 0.0,  1.0);\n	vec4  HS2 = vec4(-0.809016994,  0.587785252, 0.0,  1.0);\n	vec4  HS3 = vec4(-0.809016994, -0.587785252, 0.0,  1.0);\n	vec4  HS4 = vec4( 0.309016994, -0.951056516, 0.0,  1.0);\n	vec4  HS5 = vec4( 0.0        ,  0.0        , 1.0,  1.0);\n\n	vec4  one = vec4(1.0);\n\n	vec4 P = vec4((coords), vec2(scale, scale));\n\n	vec4 dist = vec4(0.0);\n	float inorout = -4.0;\n\n	dist.x = dot(P, HS0);\n	dist.y = dot(P, HS1);\n	dist.z = dot(P, HS2);\n	dist.w = dot(P, HS3);\n\n	dist = smoothstep(-feather, feather, dist);\n\n	inorout += dot(dist, one);\n\n	dist.x = dot(P, HS4);\n	dist.y = HS5.w - abs(P.z);\n\n	dist = smoothstep(-feather, feather, dist);\n	inorout += dist.x;\n\n	return clamp(inorout, 0.0, 1.0);\n\n}\n\n/**\n * Depth buffer blur.\n */\n\nfloat bdepth(vec2 coords) {\n\n	float d = 0.0;\n	float kernel[9];\n	vec2 offset[9];\n\n	vec2 wh = vec2(1.0 / textureWidth,1.0 / textureHeight) * dbsize;\n\n	offset[0] = vec2(-wh.x, -wh.y);\n	offset[1] = vec2(0.0, -wh.y);\n	offset[2] = vec2(wh.x -wh.y);\n\n	offset[3] = vec2(-wh.x,  0.0);\n	offset[4] = vec2(0.0,   0.0);\n	offset[5] = vec2(wh.x,  0.0);\n\n	offset[6] = vec2(-wh.x, wh.y);\n	offset[7] = vec2(0.0, wh.y);\n	offset[8] = vec2(wh.x, wh.y);\n\n	kernel[0] = 1.0 / 16.0; kernel[1] = 2.0 / 16.0; kernel[2] = 1.0 / 16.0;\n	kernel[3] = 2.0 / 16.0; kernel[4] = 4.0 / 16.0; kernel[5] = 2.0 / 16.0;\n	kernel[6] = 1.0 / 16.0; kernel[7] = 2.0 / 16.0; kernel[8] = 1.0 / 16.0;\n\n	for(int i = 0; i < 9; ++i) {\n\n		float tmp = texture2D(tDepth, coords + offset[i]).r;\n		d += tmp * kernel[i];\n\n	}\n\n	return d;\n\n}\n\n/**\n * Processing the sample.\n */\n\nvec3 color(vec2 coords, float blur) {\n\n	vec3 col = vec3(0.0);\n	vec2 texel = vec2(1.0 / textureWidth, 1.0 / textureHeight);\n\n	col.r = texture2D(tColor, coords + vec2(0.0, 1.0) * texel * fringe * blur).r;\n	col.g = texture2D(tColor, coords + vec2(-0.866, -0.5) * texel * fringe * blur).g;\n	col.b = texture2D(tColor, coords + vec2(0.866, -0.5) * texel * fringe * blur).b;\n\n	vec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n	float lum = dot(col.rgb, lumcoeff);\n	float thresh = max((lum - threshold) * gain, 0.0);\n\n	return col + mix(vec3(0.0), col, thresh * blur);\n\n}\n\n/**\n * Generating noise/pattern texture for dithering.\n */\n\nvec2 rand(vec2 coord) {\n\n	float noiseX = ((fract(1.0 - coord.s * (textureWidth / 2.0)) * 0.25) + (fract(coord.t * (textureHeight / 2.0)) * 0.75)) * 2.0 - 1.0;\n	float noiseY = ((fract(1.0 - coord.s * (textureWidth / 2.0)) * 0.75) + (fract(coord.t * (textureHeight / 2.0)) * 0.25)) * 2.0 - 1.0;\n\n	if(noise) {\n\n		noiseX = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;\n		noiseY = clamp(fract(sin(dot(coord, vec2(12.9898, 78.233) * 2.0)) * 43758.5453), 0.0, 1.0) * 2.0 - 1.0;\n\n	}\n\n	return vec2(noiseX, noiseY);\n\n}\n\n/**\n * Distance based edge smoothing.\n */\n\nvec3 debugFocus(vec3 col, float blur, float depth) {\n\n	float edge = 0.002 * depth;\n	float m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\n	float e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\n\n	col = mix(col, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\n	col = mix(col, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\n\n	return col;\n\n}\n\nfloat linearize(float depth) {\n\n	return -zfar * znear / (depth * (zfar - znear) - zfar);\n\n}\n\nfloat vignette() {\n\n	float dist = distance(vUv.xy, vec2(0.5, 0.5));\n	dist = smoothstep(vignout + (fstop / vignfade), vignin + (fstop / vignfade), dist);\n\n	return clamp(dist, 0.0, 1.0);\n\n}\n\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n\n	float rings2 = float(rings);\n	float step = TWO_PI / float(ringsamples);\n	float pw = cos(j * step) * i;\n	float ph = sin(j * step) * i;\n	float p = 1.0;\n\n	if(pentagon) {\n\n		p = penta(vec2(pw,ph));\n\n	}\n\n	col += color(vUv.xy + vec2(pw * w, ph * h), blur) * mix(1.0, i / rings2, bias) * p;\n\n	return 1.0 * mix(1.0, i / rings2, bias) * p;\n\n}\n\nvoid main() {\n\n	// Scene depth calculation.\n\n	float depth = linearize(texture2D(tDepth, vUv.xy).x);\n\n	if(depthblur) { depth = linearize(bdepth(vUv.xy)); }\n\n	// Focal plane calculation.\n\n	float fDepth = focalDepth;\n\n	if(shaderFocus) { fDepth = linearize(texture2D(tDepth, focusCoords).x); }\n\n	// Dof blur factor calculation.\n\n	float blur = 0.0;\n\n	float a, b, c, d, o;\n\n	if(manualdof) {\n\n		a = depth - fDepth; // Focal plane.\n		b = (a - fdofstart) / fdofdist; // Far DoF.\n		c = (-a - ndofstart) / ndofdist; // Near Dof.\n		blur = (a > 0.0) ? b : c;\n\n	} else {\n\n		f = focalLength; // Focal length in mm.\n		d = fDepth * 1000.0; // Focal plane in mm.\n		o = depth * 1000.0; // Depth in mm.\n\n		a = (o * f) / (o - f);\n		b = (d * f) / (d - f);\n		c = (d - f) / (d * fstop * CoC);\n\n		blur = abs(a - b) * c;\n	}\n\n	blur = clamp(blur, 0.0, 1.0);\n\n	// Calculation of pattern for dithering.\n\n	vec2 noise = rand(vUv.xy) * dithering * blur;\n\n	// Getting blur x and y step factor.\n\n	float w = (1.0 / textureWidth) * blur * maxblur + noise.x;\n	float h = (1.0 / textureHeight) * blur * maxblur + noise.y;\n\n	// Calculation of final color.\n\n	vec3 col = vec3(0.0);\n\n	if(blur < 0.05) {\n\n		// Some optimization thingy.\n		col = texture2D(tColor, vUv.xy).rgb;\n\n	} else {\n\n		col = texture2D(tColor, vUv.xy).rgb;\n		float s = 1.0;\n		int ringsamples;\n\n		for(int i = 1; i <= rings; ++i) {\n\n			// Unboxing.\n			ringsamples = i * samples;\n\n			for(int j = 0; j < maxringsamples; ++j) {\n\n				if(j >= ringsamples) { break; }\n\n				s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\n			}\n\n		}\n\n		col /= s; // Divide by sample count.\n\n	}\n\n	if(showFocus) { col = debugFocus(col, blur, depth); }\n\n	if(vignetting) { col *= vignette(); }\n\n	gl_FragColor.rgb = col;\n	gl_FragColor.a = 1.0;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};k.prototype=Object.create(b.ShaderMaterial.prototype),k.prototype.constructor=k;var I={fragment:"uniform sampler2D tDiffuse;\nuniform float time;\nuniform bool grayscale;\nuniform float nIntensity;\nuniform float sIntensity;\nuniform float sCount;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 cTextureScreen = texture2D(tDiffuse, vUv);\n\n	// Noise.\n\n	float x = vUv.x * vUv.y * time * 1000.0;\n	x = mod(x, 13.0) * mod(x, 123.0);\n	float dx = mod(x, 0.01);\n\n	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp(0.1 + dx * 100.0, 0.0, 1.0);\n\n	vec2 sc = vec2(sin(vUv.y * sCount), cos(vUv.y * sCount));\n\n	// Scanlines.\n\n	cResult += cTextureScreen.rgb * vec3(sc.x, sc.y, sc.x) * sIntensity;\n\n	cResult = cTextureScreen.rgb + clamp(nIntensity, 0.0, 1.0) * (cResult - cTextureScreen.rgb);\n\n	if(grayscale) {\n\n		cResult = vec3(cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11);\n\n	}\n\n	gl_FragColor =  vec4(cResult, cTextureScreen.a);\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};l.prototype=Object.create(b.ShaderMaterial.prototype),l.prototype.constructor=l,m.prototype.render=function(a,b,c,d){},n.prototype=Object.create(m.prototype),n.prototype.constructor=n,n.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.quad.material=this.material,a.render(this.scene,this.camera,this.renderTarget,this.clear)},o.prototype=Object.create(m.prototype),o.prototype.constructor=o,o.prototype.render=function(a,b,c,d,e){var f,g,h=a.context;h.colorMask(!1,!1,!1,!1),h.depthMask(!1),this.inverse?(f=0,g=1):(f=1,g=0),h.enable(h.STENCIL_TEST),h.stencilOp(h.REPLACE,h.REPLACE,h.REPLACE),h.stencilFunc(h.ALWAYS,f,4294967295),h.clearStencil(g),a.render(this.scene,this.camera,c,this.clear),a.render(this.scene,this.camera,b,this.clear),h.colorMask(!0,!0,!0,!0),h.depthMask(!0),h.stencilFunc(h.EQUAL,1,4294967295),h.stencilOp(h.KEEP,h.KEEP,h.KEEP)},p.prototype=Object.create(m.prototype),p.prototype.constructor=p,p.prototype.render=function(a,b,c,d,e){a.context.disable(context.STENCIL_TEST)},q.prototype.render=function(a,b,c,d){void 0!==this.shader.material.uniforms[this.textureID]&&(this.shader.material.uniforms[this.textureID].value=c),this.quad.material=this.shader.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,this.clear)},r.prototype=Object.create(m.prototype),r.prototype.constructor=r,r.prototype.render=function(a,b,c,d){var e=void 0!==this.clearColor;this.scene.overrideMaterial=this.overrideMaterial,e&&(this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha(),a.setClearColor(this.clearColor,this.clearAlpha)),a.render(this.scene,this.camera,c,this.clear),e&&a.setClearColor(this.oldClearColor,this.oldClearAlpha),this.scene.overrideMaterial=null},s.prototype=Object.create(m.prototype),s.prototype.constructor=s,s.prototype.render=function(a,b,c,d){this.quad.material=this.material,a.render(this.scene,this.camera,c)},t.prototype=Object.create(m.prototype),t.prototype.constructor=t,t.prototype.render=function(a,b,c,d){this.needsInit&&(this.reset(a),this.luminanceRT.texture.type=c.texture.type,this.previousLuminanceRT.texture.type=c.texture.type,this.currentLuminanceRT.texture.type=c.texture.type,this.needsInit=!1),this.adaptive&&(this.quad.material=this.materialLuminance,this.materialLuminance.uniforms.tDiffuse.value=c,a.render(this.scene,this.camera,this.currentLuminanceRT),this.quad.material=this.materialAdaptiveLuminosity,this.materialAdaptiveLuminosity.uniforms.delta.value=d,this.materialAdaptiveLuminosity.uniforms.lastLum.value=this.previousLuminanceRT,this.materialAdaptiveLuminosity.uniforms.currentLum.value=this.currentLuminanceRT,a.render(this.scene,this.camera,this.luminanceRT),this.quad.material=this.materialCopy,this.materialCopy.uniforms.tDiffuse.value=this.luminanceRT,a.render(this.scene,this.camera,this.previousLuminanceRT)),this.quad.material=this.materialToneMapping,this.materialToneMapping.uniforms.tDiffuse.value=c,a.render(this.scene,this.camera,b,this.clear)},t.prototype.reset=function(a){null!==this.luminanceRT&&this.luminanceRT.dispose(),null!==this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),null!==this.previousLuminanceRT&&this.previousLuminanceRT.dispose();var c={minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat};this.luminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.luminanceRT.texture.generateMipmaps=!1,this.previousLuminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.previousLuminanceRT.texture.generateMipmaps=!1,c.minFilter=b.LinearMipMapLinearFilter,this.currentLuminanceRT=new b.WebGLRenderTarget(this.resolution,this.resolution,c),this.adaptive&&(this.materialToneMapping.defines.ADAPTED_LUMINANCE=1,this.materialToneMapping.uniforms.luminanceMap.value=this.luminanceRT),this.quad.material=new b.MeshBasicMaterial({color:7829367}),this.materialLuminance.needsUpdate=!0,this.materialAdaptiveLuminosity.needsUpdate=!0,this.materialToneMapping.needsUpdate=!0},t.prototype.setAdaptive=function(a){a?(this.adaptive=!0,this.materialToneMapping.defines.ADAPTED_LUMINANCE=1,this.materialToneMapping.uniforms.luminanceMap.value=this.luminanceRT):(this.adaptive=!1,delete this.materialToneMapping.defines.ADAPTED_LUMINANCE,this.materialToneMapping.uniforms.luminanceMap.value=void 0),this.materialToneMapping.needsUpdate=!0},t.prototype.setAdaptionRate=function(a){void 0!==a&&(this.materialAdaptiveLuminosity.uniforms.tau.value=Math.abs(a))},t.prototype.setMaxLuminance=function(a){void 0!==a&&(this.materialToneMapping.uniforms.maxLuminance.value=a)},t.prototype.setAverageLuminance=function(a){void 0!==a&&(this.materialToneMapping.uniforms.averageLuminance.value=a)},t.prototype.setMiddleGrey=function(a){void 0!==a&&(this.materialToneMapping.uniforms.middleGrey.value=a)},t.prototype.dispose=function(){this.luminanceRT&&this.luminanceRT.dispose(),this.previousLuminanceRT&&this.previousLuminanceRT.dispose(),this.currentLuminanceRT&&this.currentLuminanceRT.dispose(),this.materialLuminance&&this.materialLuminance.dispose(),this.materialAdaptiveLuminosity&&this.materialAdaptiveLuminosity.dispose(),this.materialCopy&&this.materialCopy.dispose(),this.materialToneMapping&&this.materialToneMapping.dispose()},u.prototype=Object.create(m.prototype),u.prototype.constructor=u,u.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.material.uniforms.tSize.value.set(c.width,c.height),this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,!1)},v.prototype=Object.create(m.prototype),v.prototype.constructor=v,v.prototype.render=function(a,c,d){var e=this.material.uniforms;e.tDiffuse.value=d,e.seed.value=Math.random(),e.byp.value=0,this.curF%this.randX===0||this.goWild?(e.amount.value=Math.random()/30,e.angle.value=b.Math.randFloat(-Math.PI,Math.PI),e.seedX.value=b.Math.randFloat(-1,1),e.seedY.value=b.Math.randFloat(-1,1),e.distortionX.value=b.Math.randFloat(0,1),e.distortionY.value=b.Math.randFloat(0,1),this.curF=0,this.generateTrigger()):this.curF%this.randX<this.randX/5?(e.amount.value=Math.random()/90,e.angle.value=b.Math.randFloat(-Math.PI,Math.PI),e.distortionX.value=b.Math.randFloat(0,1),e.distortionY.value=b.Math.randFloat(0,1),e.seedX.value=b.Math.randFloat(-.3,.3),e.seedY.value=b.Math.randFloat(-.3,.3)):this.goWild||(e.byp.value=1),++this.curF,this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,c,!1)},v.prototype.generateTrigger=function(){this.randX=b.Math.randInt(120,240)},v.prototype.generateHeightmap=function(a){var c,d,e,f=a*a,g=new Float32Array(3*f);for(c=0;f>c;++c)d=b.Math.randFloat(0,1),g[3*c]=d,g[3*c+1]=d,g[3*c+2]=d;return e=new b.DataTexture(g,a,a,b.RGBFormat,b.FloatType),e.needsUpdate=!0,e};var J=new b.Vector2(.001953125,0),K=new b.Vector2(0,.001953125);w.prototype=Object.create(m.prototype),w.prototype.constructor=w,w.prototype.render=function(a,b,c,d,e){e&&a.context.disable(a.context.STENCIL_TEST),this.quad.material=this.convolutionMaterial,this.convolutionMaterial.uniforms.tDiffuse.value=c,this.convolutionMaterial.uniforms.uImageIncrement.value=J,a.render(this.scene,this.camera,this.renderTargetX,!0),this.convolutionMaterial.uniforms.tDiffuse.value=this.renderTargetX,this.convolutionMaterial.uniforms.uImageIncrement.value=K,a.render(this.scene,this.camera,this.renderTargetY,!0),this.quad.material=this.copyMaterial,this.copyMaterial.uniforms.tDiffuse.value=this.renderTargetY,e&&a.context.enable(a.context.STENCIL_TEST),a.render(this.scene,this.camera,c,this.clear)},x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.render=function(a,b,c,d,e){this.quad2.material=this.bokehMaterial,this.scene.overrideMaterial=this.depthMaterial,a.render(this.scene,this.camera,this.renderTargetDepth,!0),this.bokehMaterial.uniforms.tColor.value=c,this.renderToScreen?a.render(this.scene2,this.camera2):a.render(this.scene2,this.camera2,b,this.clear),this.scene.overrideMaterial=null},y.prototype=Object.create(m.prototype),y.prototype.constructor=y,y.prototype.render=function(a,b,c,d){this.material.uniforms.tDiffuse.value=c,this.material.uniforms.time.value+=d,this.quad.material=this.material,
this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,!1)},z.prototype.swapBuffers=function(){var a=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=a},z.prototype.addPass=function(a){this.passes.push(a)},z.prototype.insertPass=function(a,b){this.passes.splice(b,0,a)},z.prototype.render=function(a){this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2;var b,c,d,e,f=!1;for(d=0,e=this.passes.length;e>d;++d)c=this.passes[d],c.enabled&&(c.render(this.renderer,this.writeBuffer,this.readBuffer,a,f),c.needsSwap&&(f&&(b=this.renderer.context,b.stencilFunc(b.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,a),b.stencilFunc(b.EQUAL,1,4294967295)),this.swapBuffers()),c instanceof o?f=!0:c instanceof p&&(f=!1))},z.prototype.reset=function(a){var b;void 0===a&&(a=this.renderTarget1.clone(),b=this.renderer.getPixelRatio(),a.width=Math.floor(this.renderer.context.canvas.width/b),a.height=Math.floor(this.renderer.context.canvas.height/b)),this.renderTarget1.dispose(),this.renderTarget1=a,this.renderTarget2.dispose(),this.renderTarget2=a.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},z.prototype.setSize=function(a,b){this.renderTarget1.setSize(a,b),this.renderTarget2.setSize(a,b)},a.EffectComposer=z,a.Pass=m,a.SavePass=n,a.MaskPass=o,a.ClearMaskPass=p,a.ShaderPass=q,a.RenderPass=r,a.TexturePass=s,a.AdaptiveToneMappingPass=t,a.DotScreenPass=u,a.GlitchPass=v,a.BloomPass=w,a.BokehPass=x,a.FilmPass=y,a.CopyMaterial=c,a.LuminosityMaterial=d,a.AdaptiveLuminosityMaterial=e,a.ToneMappingMaterial=f,a.DotScreenMaterial=g,a.GlitchMaterial=h,a.ConvolutionMaterial=j,a.BokehMaterial=k,a.FilmMaterial=l});